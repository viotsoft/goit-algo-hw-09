
## Пояснення роботи алгоритмів

### Жадібний алгоритм (`find_coins_greedy`)

1. **Ідея:** Починати з найбільшого номіналу та доки ми можемо додавати цей номінал (тобто поки він не перевищує залишок суми), додаємо його в результат. Потім переходимо до наступного меншого номіналу.
2. **Часова складність:**  
   - У найгіршому випадку для суми \(N\) ви перебираєте усі номінали, зокрема найдрібніші. Якщо монет небагато (фіксована кількість номіналів), алгоритм працює дуже швидко, приблизно за \(O(N / \min(\text{coin}))\) у гіршому випадку (коли частіше за все додаються дрібні монети).  
   - Якщо ж кількість номіналів вважається константою (наприклад, як у типовій валюті), то, грубо кажучи, це дасть майже лінійний час від суми \(N\).
3. **Недолік:** Жадібний підхід не завжди знаходить оптимальний (мінімальний) набір монет, але для класичних наборів монет (наприклад, більшості валют) він працює оптимально.

### Динамічне програмування (`find_min_coins`)

1. **Ідея:** Використовуємо таблицю (список) `dp`, де для кожної суми від `0` до `N` зберігається мінімальна кількість монет, необхідна для формування цієї суми, а також словник, який описує, якими саме монетами ця сума складається.
2. **Часова складність:**  
   - Якщо нехай сума дорівнює \(N\) і кількість номіналів дорівнює \(M\), алгоритм проходитиметься по всіх сумах від 1 до \(N\) та по всіх монетах \(M\). Це дає складність \(O(N \times M)\).
   - Якщо \(M\) — константа (наприклад, 6 номіналів у нашому прикладі), складність спрощується до \(O(N)\). Проте з ростом \(N\) таблиця збільшується лінійно з \(N\), що може бути досить ресурсномістким для дуже великих сум.
3. **Перевага:** Знаходить **справді мінімальну** кількість монет для **будь-якого** набору номіналів.

---

## Порівняння продуктивності

1. **Швидкодія (Big-O)**:  
   - Жадібний алгоритм у типовому випадку працює приблизно за \(O(N)\) (якщо \(M\) фіксоване), або навіть швидше (бо часто вже за кілька кроків знаходить потрібну кількість великих монет).  
   - Динамічне програмування працює за \(O(N \times M)\). При невеликому \(M\) це також \(O(N)\). Проте внутрішні операції формування таблиці та копіювання словників можуть бути досить «важкими» для дуже великих сум.

2. **Оптимальність**:  
   - Жадібний алгоритм підходить для класичних наборів монет (наприклад, 1, 2, 5, 10, 25, 50, 100 тощо), де він зазвичай дає мінімальну кількість монет. Але в загальному випадку **може** давати не оптимальне рішення.  
   - Алгоритм динамічного програмування **завжди** дасть оптимальне рішення, незалежно від набору монет, проте час роботи може бути вищим для великих сум.

3. **Використання**:
   - Жадібний алгоритм застосовують, коли сума велика, але відомо, що набір монет у більшості випадків «зручний» (класичні валюти), і не критично отримати «не найоптимальніший» розклад монет (або він справді оптимальний через специфіку набору монет).  
   - Динамічне програмування потрібне, коли **обов’язково** потрібен найменший можливий набір монет (або коли набір монет нетривіальний і жадібний алгоритм може давати неправильну відповідь).

---

**Висновок:**  
- Якщо вам потрібен обов’язково **оптимальний** спосіб видачі решти за будь-якого набору монет, використовуйте динамічне програмування.  
- Якщо ж набір монет «класичний» (як-от у звичайній валюті), і ви обираєте швидкість та простоту реалізації, а також вам не потрібна надточна оптимізація, жадібний алгоритм буде переважно швидшим і простішим.
